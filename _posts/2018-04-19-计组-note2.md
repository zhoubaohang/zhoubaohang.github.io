---
layout: post
title: 计算机组成原理笔记2
date: 2018-4-19
author: 周宝航
categories: blog
tags: [计算机组成原理]
description: 计组知识点总结
---

# 计算机组成原理——处理器
[TOC]

## 简介
***作用：***：CPU作为一台电脑中的核心，它的作用是无法替代的。
***实质:***:
CPU本身只是在块硅晶片上所集成的超大规模的集成电路，集成的晶体管数量可达到上亿个，是由非常先进复杂的制造工艺制造出来的，拥有相当高的科技含量。

## 处理器的指令集
### 机器指令
***定义：***
计算机能直接识别的是由0和1排列而成的指令，即所谓“机器指令”
***汇编语言：***
***简要：***
汇编语言是基于英文的机器指令助记符。
例如，某个机器指令原来用0101表示加法运算，现在引入助记符ADD或add来表示0101，方便了人们编写程序。
***意义：***
①汇编语言的提出是计算机技术的一大进步，体现了计算思维的一个重要概念——抽象。
②计算机程序设计语言的发展过程就是不断抽象的过程。通过抽象，程序设计语言具有了更好
   的可编程性、可移植性、可重用性。
### 概述
***基本概念：***
*机器指令*：计算机能够直接进行某种基本操作的二进制代码语言。
*指令集*：全部机器指令的集合，是表征计算机性能的重要指标。
*指令系统*：包括 ***指令*** ***寻址方式*** ***数据标识***
*任务*：指令设计者——如何用具体的硬件电路芯片设备来实现机器指令系统的功能。指令使用者——使用指令来编制程序，完成预定任务。
### 指令的操作码与操作数
#### 指令的格式
***基本格式***： |指令操作码|指令操作数（地址码）|
***PS***：CPU中有专门的译码电路用以识别解释每个操作码。
***指令操作数***：
功能：用来指出操作数的地址（如：源操作数地址、结果（目的操作数地址）、下一条指令的地址）
地址可以是：内存地址、CPU中的寄存器地址、I/O设备地址
分类：
四地址指令、三地址指令、二地址指令、一地址指令、零地址指令。
***数据表示***：
*定义*：指令中所能表示的操作数数据类型，即能够被计算机硬件直接辨识的操作数数据类型，称为“数据表示”。
*常见数据表示*：
①定点数（含有符号数和无符号数）、
②浮点数（含单精度浮点数和双精度浮点数）、
③字符、
④逻辑数（又称布尔型数据）。
#### 堆栈的概念
***“堆栈(Stack)”是一个重要的数据结构，广泛应用于子程序调用和中断服务等领域。堆栈的存取原则是后进先出(Last In First Out, LIFO)。***

*基本操作*：对堆栈的操作都是针对栈顶单元进行的，有:
① “压入(PUSH)”
② “弹出(POP)”两条指令。

***硬件堆栈：用专门的硬件设备来实现的堆栈称为级联堆栈或硬件堆栈。***
例如：CPU内的若干个寄存器可构成堆栈

***软堆栈：为了降低硬件成本，大多数计算机（特别是微型计算机）常用软件来实现堆栈：即在内存中开辟一个堆栈区，并在处理器中设置指示堆栈栈顶单元地址的“堆栈指针寄存器(Stack Pointer, SP)”来管理这个堆栈。***
优点：可以有较大的深度。可以设置多个堆栈。可以设置多个堆栈。
#### 复杂的数据表示
除了基本数据表示外，大型机中一般会引入较为复杂的高级数据表示，
例如：
①向量数据表示和
②带标志符数据表示等。

***标量处理器 只有标量数据表示和标量指令的处理器叫标量处理器，这是最常见、最通用的处理器。***

***向量处理器 带有向量数据表示和向量指令的处理器叫向量处理器，例如我国于20世纪80年代研制的银河-1超级计算机就装备有向量处理器。***

### 寻址方式
***含义***： “寻址方式”是用以确定
① 本条指令 的 操作数地址  ②下一条 欲执行 指令 的 指令地址

***分类***：
“指令寻址”：指令寻址是为了找到下一条指令
“数据寻址”：数据寻址是为了找到本条指令所需的操作数

#### 指令寻址
***顺序寻址***：
顺序寻址就是程序计数器PC中的值就是下一条指令的存储地址。每读取一次PC后，PC自动加1，指向下一条指令。

***跳跃寻址***：
跳跃寻址则是先由当前指令改写PC的内容，然后计算机读取PC，根据PC的值访问主存储器，取下一条指令。

***PS*** :
改写PC的指令有“跳转指令(Jump 无条件转移指令)”和“分支指令(Branch 条件转移指令)”
这两种指令既可直接赋予PC一个新的值，也可在PC现有值的基础上增加或减少一定数量。后者也称“相对寻址”或“PC相对寻址”，其中增加或减少的数量叫做“相对位移量”，它是一个补码表示整数。

#### 数据寻址
格式 ：
```
|          操作码      |寻址特征|形式地址A|
| （描述指令功能）     | (决定寻址方式)   |
```
***精髓***：
由形式地址找到有效地址的过程。
> 形式地址（EA）：指令字中的地址
> 有效地址（EA）: 操作数的真实地址

##### 立即数寻址
***定义***：在指令中直接给出操作数的数值。只要取到指令，就可以立即处理指令中的操作数，这种操作数叫做 “立即数”。

格式：
```
| OP |     #      |  A   |
|    |立即寻址特征|立即数|
```
结果：形式地址 A 就是操作数 且A可正可负（补码表示）
特点：
> 1、指令执行阶段不访存 
> 2、A的位数限制了立即数的范围

##### 直接寻址
公式：EA = A 有效地址由形式地址直接给出
变换过程：
```
|OP|寻址特征|A|
             |      |主存  |
             --> A  |操作数|->ACC(CPU内的累加寄存器)
```
特点：
> 1、 执行阶段访问1次存储器
> 2、 A的位数决定了该指令操作数的寻址范围
> 3、 操作数的地址不易修改

##### 间接寻址
公式：EA = （A） 有效地址由形式地址间接提供
过程：
```
一次简址
|OP|寻址特征|A|     主存
		     |    |      |
             -->A | EA   |-----
                  |      |    |
                  |操作数|EA <-
```
特点：
> 1、 执行阶段2次访存/多次访存
> 2、 可扩大寻址范围
> 3、 便于编制程序

##### 寄存器（直接）寻址
公式 EA = Ri 有效地址即为存储器编号
变换过程：
```
|OP|寻址特征|Ri|
			 |  R0 |        |
             |  ...|  ...   |
             -->Ri | 操作数 |
                     寄存器
```
特点：
> 1、 执行阶段不访存，只访问寄存器
> 2、 寄存器个数有限，可缩短指令字长

##### 寄存器间接寻址
公式：EA = （Ri）  有效地址在寄存器中
变换过程：
```
|OP|寻址特征|Ri|                      主存
			 |  R0 |        |       |       |
             |  ...|  ...   |       |       |
             -->Ri |  地址  |  -->  |操作数 |
                     寄存器
```
特点：
> 1、 有效地址在寄存器中，操作数在存储器中
> 2、 可适当扩大程序寻址范围

##### 基址寻址
采用专用寄存器做基址寄存器
公式：EA = （BR） + A *（BR 为基址寄存器）*
变换过程：
```
|OP|寻址特征|A|
             |
             v
     BR -->|ALU|     主存
     		|     |      |
             --->  |操作数|
```
特点：
> 1、 可扩大寻址范围
> 2、 便于程序浮动
> 3、 BR内容由操作系统或管理程序决定
> 4、在程序的执行过程中BR内容不变，形式地址A可变。

“逻辑地址”：程序员编写程序时使用的地址。
“主存物理地址”：是程序段/数据段在主存中的实际存放地址。

解决方案：
为了实现++“逻辑地址”++到++“主存物理地址”++的转换，可以在处理器内部设置一个寄存器：专门存放程序段/数据段在主存中起始地址的寄存器，称起始地址为++“基地址”++，简称++“基址”++，称该寄存器为++“基址寄存器”++。这样在执行时将++“逻辑地址”++与++基址寄存器中的值++相加即得到指令或数据的++“主存物理地址”++。

指令中给出的“逻辑地址”又称为相对于基址的“位移量”，位移量是一个有符号的整数，常用补码表示。

##### 变址寻址
公式： EA = （IX） + A
1、IX为变址寄存器（专用）2、通用寄存器也可作为变址寄存器

变换过程：
```
|OP|寻址特征|A|
             |
             v
     IX -->|ALU|     主存
     		|     |      |
             --->  |操作数|
```
特点：
> 1、 可扩大寻址范围
> 2、 IX的内容由用户给定
> 3、 在程序的执行过程中IX内容可变，形式地址A不变。
> 4、 便于处理数组问题。

***引出***：
为支持用循环结构处理数组/向量而提出。
***寻址过程***：
将数组/向量的起始地址作为操作数在指令中给出，将数组/向量的元素下标i存放在一个专门的寄存器——变址寄存器中。指令执行时，用变址加法器将指令中的起始地址与变址寄存器中的内容相加，得到数组/向量元素的地址。
***实际***：
为了支持同时处理多个数组或向量，处理器可设置多个变址寄存器。
例如，8086微处理器有2个变址寄存器：
a.一个是存放源操作数变址值的寄存器SI，
b.另一个是存放目的操作数变址值的寄存器DI。
此时，采用 “变址寻址”指令中除了要给出数组/向量的起始地址外，还需指明使用的是哪个变址寄存器。
***联合使用***：
变址寻址还可与其他寻址方式结合使用。
例如与基址寻址结合可得到“基址变址寻址”，与“间接寻址”结合可以得到“先变址后间接寻址”等。

##### 堆栈寻址
***堆栈***：
> 采用“堆栈寻址”的前提是处理器支持堆栈数据结构，设置有：“堆栈指针寄存器SP”
> “堆栈寻址”无须给出操作数的存储地址，只要声明操作数采用堆栈寻址，机器就会根据栈顶指示寄存器的内容找到栈顶单元，然后对栈顶单元进行弹出或压入操作。

***堆栈分类***：
根据堆栈的增长方向，基于主存储器实现的堆栈分为：
>    	① 递增堆栈(Ascending Stack) ，也称向上增长堆栈。
>    	   随着数据的压入，这种堆栈向高地址方向增长；
>    	② 递减堆栈(Descending Stack) ，也称向下增长堆栈。
>    	    随着数据的压入，这种堆栈向低地址方向增长。

根据SP所指示栈顶单元的属性，堆栈也可分为：
>        ① 满堆栈(Full Stack) 。
>             SP指示栈顶单元存储的是最后压入数据。
>        ② 空堆栈(Empty Stack) 。
>             SP指示栈顶单元用于接收下一个要压入的数据。 

***堆栈特点***：
```
     硬堆栈   多个寄存器
堆栈
	 软堆栈   指定的存储空间
|先进后出（一个入出口）|栈顶空间由SP指出|
|进栈（sp）-1 -----> SP|出栈（sp）+1->sp|
```
***SP的修改与主存变址方式有关***
> 	1、按字编址  
> 		PUSH(SP)-1 ---> SP  POP(SP)+1 ---> SP
> 	2、按字节编址（存储字长16位）
> 		PUSH(SP)-2 ---> SP  POP(SP)+2 ---> SP
> 	3、按字节编址（存储字长32位）
> 		PUSH(SP)-4 ---> SP  POP(SP)+4 ---> SP

##### 习题
```
【3-1】某机器字长16位，主存按字节编址，转移指令采用相对寻址，由两个字节组成，第一字节为操作码字段，第二字节为相对位移量字段。假定取指令时，每取一个字节PC自动加1。若某转移指令所在主存地址为2000H，相对位移量字段的内容为06H，则该转移指令成功转移后的目标地址是     C     。
A．2006H     B．2007H     C．2008H        D．2009H

【3-2】偏移寻址通过将某个寄存器内容与一个形式地址相加而生成有效地址。下列寻址方式中，不属于偏移寻址的是    A   。
A.间接寻址   B.基址寻址    C.相对寻址   D.变址寻址
```

#### 指令的基本功能
通用计算机系统的指令集可分为5类基本指令：
>	（1）算术/逻辑/移位指令（简称算逻指令）
>   （2）数据传送指令（简称数传指令）
>   （3）控制转移指令
>	（4）输入/输出指令
>   （5）处理器控制及调试指令

##### 算逻指令
***算数指令举例***
>	定点加法指令ADD
>	定点减法指令SUB
>	定点乘法指令MUL
>	定点除法指令DIV
>	加1指令INC
>	减1指令DEC
>	比较指令CMP
>	浮点加法指令ADDF
>	浮点减法指令SUBF
>	浮点乘法指令MULF
>	浮点除法指令DIVF
>	十进制数算术运算指令

***逻辑指令***
>	“与”运算指令AND
>	“或”运算指令OR
>	“非”运算指令NOT
>	“异或”运算指令XOR
>	位测试
>	位清除
>	位求反

***移位指令***
>	算术左移指令
>	算术右移指令
>	逻辑左移指令
>	逻辑右移指令
>	带进位循环左移指令
>	不带进位循环左移指令
>	带进位循环右移指令
>	不带进位循环右移指令

##### 数传指令
***分类1***
根据数据的流向划分
***分类2***
根据传输的功能分

**（1）一般传送指令**
现数据复制功能，即把源操作数的内容写入目的操作数。其汇编语言助记符通常为MOV。
在有些计算机上，
①将主存储器单元的内容写入寄存器的数据传送指令，其汇编语言助记符为LOAD；
②将寄存器内容写入主存储器单元的数据传送指令，其汇编语言助记符为STORE。

**（2）堆栈操作指令**
压入栈顶PUSH
弹出栈顶POP
PUSH的源操作数和POP指令的目的操作数，一般是寄存器号，
也可能是主存储器单元地址.

**（3）PS**
上述两类数据指令的数据流动是单方向的。要实现两个数据的交换，需要
编写3条指令并额外占用1个存储单元。

因此大多数计算机都提供“数据交换指令”来简化双向数据流动的实现，如Intel 80x86中的XCHG指令。

这类指令的源操作数和目的操作数一般都是寄存器，至多允许源操作数是
主存储器单元。

数据交换指令的执行时间一般较长。

##### 控制转移指令
> 跳转指令JUMP
> 分支指令
> 子程序调用CALL/返回指令RET
> 循环控制指令LOOP
> 中断系统指令

***（1）跳转指令JUMP***
将指令操作数的内容写入PC之中，强制改变指令执行的顺序。也称无条件转移指令

***（2）分支指令***
根据特定条件（往往是上一条指令的执行结果），决定程序是顺序执行还是转移到一个新的位置执行，即有条件地改变指令执行的顺序。也称条件转移指令。

**条件转移指令可能依据的条件**有：为0、为正/负数、发生进位/借位、为奇数/偶数、发生溢出或以上条件的组合。

**条件转移指令又分为“绝对转移”和“相对转移”两种**
对于“绝对转移”，当条件满足时，计算机将把该指令中所含操作数的内容直接写入PC中。
对于“相对转移”，当条件满足时，计算机将把该指令中所含操作数的内容与PC中的内容相加后，把结果写入PC中。

**常见跳转指令：**
> 等于零转移BEQ
> 不等于零转移BNEQ
> 小于转移BLS
> 大于转移BGT
> 小于等于转移/不大于转移BLEQ
> 大于等于转移/不小于转移BGEQ
> 不带符号小于转移BLSU
> 不带符号大于转移BGTU
> 不带符号小于等于转移/不带符号不大于转移BLEQU
> 不带符号大于等于转移/不带符号不小于转移BGEQU


***（3）子程序调用CALL/返回指令RET***
**引出**
程序中，有一些具有特定功能的程序段会被反复使用。为了提高程序的可读性、可重用性和可维护性，人们将这样的程序段独立出来，将其定义成一个子程序。

这样，在需要执行特定功能时，主程序中不再需要编写一个程序段，而只需要编写一条调用子程序的指令即可。

**基本格式**
调用子程序的指令格式: CALL Subprogram_Name
**功能是**
>		①首先把当前程序的断点（也称主调程序的返回地址，即当前程序计数器PC中的值）保存到系统堆栈中
>		②然后由子程序名：Subprogram_Name求得子程序的入口地址，
>		③最后把子程序的入口地址写入PC，从而将程序控制转移至被调子程序。
调用子程序指令CALL一般都与“返回指令RET”一起配合使用。
RET指令的功能是把保存在堆栈中的程序断点弹回到PC之中。

##### 输入输出指令
**功能**
启动与停止输入/输出设备、测试输入/输出设备
检查外设状态
在外设与外设之间外设与内存之间进行信息传输
*举例*
例如，Intel 80x86中的输入指令为IN指令，输出指令为OUT指令。

##### 处理器控制及调试指令
>		①各种设置/清除标志位（如陷阱标志、中断允许标志、处理器工作状态标志位）指令、
>		②特权指令、
>		③进程同步指令、
>		④调试指令、
>		⑤停机指令（HALT）等。
调试指令用于硬件或软件的调试。
硬件调试指令包括钥匙位置、开关状态的读取指令，重要寄存器和主存储器单元内容的显示等。
软件调试指令包括断点的设置及跟踪指令，自陷阱指令等。

**核心态(Kernel mode /System mode)和用户态(User mode)**
对于面向多用户系统的处理器,为了保证信息安全，处理器的工作状态被分为：核心态(Kernel mode /System mode)和用户态(User mode)。

能在核心态(也叫管理态/管态)下运行的指令称为：特权指令(Privileged instruction)。

用户态(也叫目态)下的程序要想执行管态下的功能（由操作系统实现并提供用户使用）必须通过执行“访管指令”来实现。

访管指令是一条可以在目态下执行的指令，用户程序中凡是要调用操作系统功能的地方就安排一条访管指令。当执行到访管指令时，处理器就自愿地产生一个中断事件（访管中断），暂停用户程序的执行，陷入管态，让操作系统为用户服务。

#### 指令的格式
包括：
>	①指令的操作码长度、
>	②指令“地址制”及采用的寻址方式、
>	③指令长度

##### 指令长度
长度固定：
>便于硬件设计，指令译码时间短
>用于大中小型机。如  IBM  370操作码  8  位

长度不固定：
>		操作码长度可变
>		操作码分散在指令字的不同字段中
>		控制器设计复杂，指令译码分析时间长
>		适用于微型机中。如Intel 8086、80386
>		选择不定长操作码（也称扩展操作码）可使常用指令拥有较短的操作码而不常用指令拥有较长的操作码（即哈夫曼压缩编码)，从而压缩程序所占的存储空间。

##### 地址制（即地址码情）
**(1)四地址格式**
格式
```
|  8   |       6        |       6        |   6      |   6      |
|  OP  |       A1       |       A2       |   A3     |   A4     |
|      | 第一操作数地址 | 第二操作数地址 |结果的地址|下一指令地址|
```

功能
(A1) OP (A2)-----> A3
A4------->PC

举例
```
设指令字长为 32 位，操作码固定为 8 位
则指令从取出到执行完毕，需要  4次  访存，寻址范围是 64 (2的6次方)。
```

**（2）三地址格式**
格式
```
|  8   |       8        |       8        |   8      |
|  OP  |       A1       |       A2       |   A3     |
|      | 第一操作数地址 | 第二操作数地址 |结果的地址|
```

功能
(A1) OP (A2) ------> A3
PC++ 即地址自动加1，指向下一条指令在内存的地址

举例
```
设指令字长为 32 位，操作码固定为 8 位
则指令从取出到执行完毕，需要  4次  访存，寻址范围是 256 (2的8次方)。
```

**(3)二地址格式**
格式
```
|  8   |       12       |       12       |
|  OP  |       A1       |       A2       |
|      | 第一操作数地址 | 第二操作数地址 |
```

功能：
(A1) OP (A2)  ---->  A1
(A1) OP (A2)  ---->  A2

举例
```
设指令字长为 32 位，操作码固定为 8 位
则指令从取出到执行完毕，需要  4次  访存，寻址范围是  4k (2的12次方)。若结果存于 ACC,    3次    访存.
```

**（4）一地址格式**
格式
```
|  8   |       24       |
|  OP  |       A1       |
|      |   源操作数地址 |
```

功能
(ACC) OP (A1) ---->  ACC

举例
```
设指令字长为 32 位，操作码固定为 8 位
则指令从取出到执行完毕，需要  2次  访存，寻址范围是  16M (2的24次方)。
```

**零地址格式**
格式
```
|      OP        |
```
举例
> 中断返回指令 RTN
> 停机指令HLT

##### 小结
**“地址制”设计或改进的目的**
是为了压缩指令长度，缩短指令的执行时间。在相同的指令长度内，减少地址个数可以扩大所能表示指令的条数或操作数的寻址范围。

**同一条指令中不同操作数可采用不同的寻址方式**：
例如，一条指令中的操作数可以都存放在寄存器里，也可以把一个操作数
存放在寄存器里，而另一个操作数存放在主存里。存放在主存里的操作数
可以按基址寻址、变址寻址或间接寻址。

**指令长度可以是固定或变化的。**
固定长度的指令便于指令的存取和译码，但会限制操作数个数的增加和复杂寻址方式的使用；而变化长度的指令的特点正好相反。

例如，IBM S/ 370指令采用定长的8位操作码，有单地址、两地址和三地址三种地址制，不同的操作数可以采用不同的寻址方式，指令字长有16位、32位和48位三种。

## 处理器的基本功能和基本组成
### 处理器概述
实现处理器内部各个单元之间信号传输的线路称为**片内总线**，它又分为**片内控制总线**和**片内数据总线**。

用于实现处理器与主存储器和输入/输出设备之间信号传输的线路称为**片外总线**，简称**总线**。

除了电源引脚（Vcc）和接地引脚（GND）外，大部分引脚都用于信号
传输。按照传输信号类别的不同，这些引脚可以分为:
>	①数据总线引脚 D0、D1、....Dn
>	②地址总线引脚 A0、A1、....An
>	③控制总线引脚
>>	时钟CLK、
>>	复位RESET、
>>	总线请求HRQ、
>>	总线允许HLDA、
>>	中断请求INTR、
>>	中断响应INTA、
>>	读RD、
>>	写WR等。

### 处理器的基本功能
```
|取指令|--->|分析指令|--->|取数据|--->|处理数据|--->|写回结果|
```
**（1）取指令**
处理器根据PC给出的主存地址访问主存储器，取出一个标准字长的指令，将其送入处理器内部专门存放当前指令的指令寄存器 IR，然后PC加1。


寄存器 | 名称        |存放内容
------|-------------|------
MAR|存储器地址寄存器|存放欲读写的存储单元的地址（与系统地址总线相连接）
MDR|存储器数据寄存器|存放欲读写存储器的数据信息（与系统数据总线相连接）
PC|程序计数器|存放CPU当前正在执行的指令的下一条指令在内存的地址
IR|指令寄存器|存放CPU当前正在执行的指令

**（2）分析指令**
①处理器将IR中的操作码部分取出送入指令译码器（Decoder）进行译码。
②根据译码结果判断出：
> 指令的功能（即指令将要执行什么操作）、
> 操作数的寻址方式以及操作数的数据类型，
> 形成源操作数或目的操作数的物理地址。

**（3）取数据**
根据源操作数的物理地址访问主存，取出源操作数。源操作数将被送入处理器内部的数据寄存器，如累加器ACC。

**（4）处理数据**
处理器将源操作数送入运算器，并根据指令译码结果启动运算器的相应操作对数据进行处理。处理结果存回通用数据寄存器或缓冲寄存器。

**（5）写回结果**
如果指令要求将结果写回主存，那么处理器将根据目的操作数的地址，将目的操作数写入主存。

访问主存是处理器经常执行的一个公共操作。为此，处理器设置了：
> ①专门存放访存地址的寄存器MAR、
> ②专门存放与主存交换数据的寄存器MDR/MBR。


只要把主存地址送入MAR，启动读命令，在1个访存周期内，目标数据就会从主存被读入到MDR中；
或者只要把主存地址送入MAR并把目标数据送入MDR，启动写命令，在1个访存周期内，目标数据就会从MDR被写回到主存中。

#### ALU
处理数据的功能单元叫算术逻辑单元ALU，它的功能是对数据进行各种算术运算或逻辑运算。
#### CU
根据冯·诺依曼型计算机的特点，处理器的所有工作都是在控制单元CU的指挥下完成的。

**CU的功能**是，通过对指令的分析(译码)，按照一定的时序，发出控制信号，使CPU在控制信号的驱动下，完成相应指令的功能。

> 产生全部指令的微操作命令序列
> 控制和协调各部件工作
> 实现方式
>> 微程序设计：存储逻辑
>> 组合逻辑设计：硬连线逻辑

```
|取指令|---->|分析指令|---->|执行指令|
取指令：从内存提取指令
分析指令：分析指令的操作类型、分析操作数的来源
执行指令：发出控制信号序列
```

#### 寄存器
但是即使是汇编语言程序员，处理器内部的某些寄存器也是无须关心的，如MAR和MDR。即，MAR和MDR对汇编程序员是“透明的”。

寄存器分为“用户可见的寄存器”和“用户透明的寄存器”，
这里的“用户”是指汇编语言程序员
用户可见的寄存器|用户透明的寄存器
-------------|-------------
①数据寄存器|①MAR
②基址寄存器|②MDR
③变址寄存器|③ALU的输入寄存器A和B
④FR|输出寄存器SUM
⑤PC|

#### 中断
中断已经成为计算机/处理器不可或缺的功能。没有中断，很多现代计算机系统的功能（比如多用户、多任务）都无法实现。

所谓中断，是指计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机会在适当时机暂停现行程序的运行，转向执行处理这些异常情况或特殊请求的程序（即中断处理程序或中断服务程序），处理结束后再返回到现行程序的间断处继续执行。

**中断源**
能够发出中断请求的部件或事件，称为“中断源”。为了区分不同请求信号，不同的中断源被赋予了一个不同的“中断类型号”。
```
-----中断------------------------------------------------>t
	随机             固定                    固定
外设向CPU发出中断     指令执行结束前        在每条指令结束时，
申请的时间是随机的    CPU向接口发出中断	  CPU去执行中断服务程序
                     查询信号，获取I/O
                     中断请求。将INTR置1
```

由于中断请求信号到来的时间是随机的，处理器不可能随时对它进行处理。

通常约定：**中断可以中断程序，但不能中断指令。**

处理器只会在指令执行的末尾，去检测是否有中断请求。若有，并且处理器处于允许响应的状态，则响应中断请求，否则执行下一条指令。

为此，**控制总线**要增加：
①接收中断请求(Interrupt Request)信号的引脚INTR
②发出中断响应(Interrupt Acknowledge)信号的引脚INTA。
**处理器内部**要设置：
①一个“中断允许(Enable Interrupt, EINT)”标志和
② 一个中断状态触发器“INT”。
可以通过“开中断(Set Interrupt, STI)”指令将EINT置为1，
也可以通过“关中断(Clear Interrupt, CLI)”指令将EINT清成0。

++处理器内部与中断有关的逻辑电路称为中断单元，实现中断的所有硬件和软件称为中断系统。++

#### 习题
```
下列选项中，能引起外部中断的事件是     A     。
A.键盘输入     B.除数为0     C.浮点运算下溢     D.访存缺页
答：根据中断源位于处理器的内部还是外部，中断分为内部中断和外部中断。

内部中断的例子有：除数为0，溢出，非法访问（如越界访问等。
外部中断的例子有：来至外设的中断（如键盘输入），来至定时器的时钟中断等。
“访存缺页”属于故障，不是中断。故选A。
```

### 计算机的工作过程
#### 指令周期、机器周期、时钟周期（节拍）
> 1、把处理器取出并执行一条指令称为对指令的解释（Interpret）
> 2、处理器每取出并执行一条指令所需的全部时间叫指令周期。
> 3、在一个指令周期内，处理器所要完成的操作有“取指”和“执行”
>> “取指”就是将一条指令从主存取入到处理器中，
>> “执行”就是对指令进行译码并完成其指定的操作

##### 指令周期
**指令周期示意图**
```
|		取指		|		执行		|
|<-    取指周期    ->|<-     执行周期   ->|
|<-             指令周期                ->|
```
**间址周期示意图**
为了取到操作数，在取指周期之后还有一个访问主存，读取操作数地址的周期，这个周期就是间址周期。
```
|		取指		|		间址		|		执行		|
|<-    取指周期    ->|<-    间址周期    ->|<-     执行周期   ->|
|<-                        指令周期                          ->|
```
**不同指令所完成的功能不同，所以它们的指令周期也不尽相同**

##### 机器周期
由于不同指令的指令周期不尽相同，为了简化控制，一般将其设计成某个基准周期的整数倍，这个基准周期称为机器周期。

机器周期是所有指令执行过程中的一个基准时间。

指令操作分为处理器内部操作和对主存的访问两类：
> ①前者完成时间较短，
> ②而后者完成时间较长。


为了保证在一个机器周期至少能够完成一个指令的基本操作，选取处理器**访问一次主存的时间(也称主存周期)作为机器周期**。

通常用内存中读取一个指令字的最短时间来规定CPU周期。(也就是计算机完成一个基本操作所花费的时间)

***若指令字长=存储字长，则 取指周期=机器周期***

##### 时钟周期
在一个机器周期内，处理器需要完成若干带有时序限制的微操作，每个微操作的完成也需要一定的时间。为了实现对微操作的控制，处理器用**时钟信号CLK**来控制每一个微操作命令的产生。

这样，在一个机器周期内又包含了若干时钟周期（也称节拍）。
> ①一个节拍的宽度正好等于一个时钟周期。
> ②在一个节拍内，处理器完成一个或几个可以同时执行的微操作。

**时钟周期：一个机器周期内包含了若干个时钟周期，是处理器操作的最基本单位**
在一个时钟周期内机器可完成一个或几个需同时执行的操作。
```
						    |
时  -----微操作命令----> 机 |  完成一个微操作
钟  -----微操作命令----> 器 |      完成一个微操作
信  -----微操作命令----> 周 |          完成一个微操作
号  -----微操作命令----> 期 |              完成一个微操作
						    v  t
```
**PS**:时钟周期 == 节拍脉冲 == 节拍状态  == T周期

##### 三者之间的关系
指令周期、机器周期和节拍的关系如下图所示。
```
|<-            指令周期                 ->|
|<-    机器周期    ->|<-     机器周期   ->|
| 节拍 | 节拍 | 节拍 | 节拍 | 节拍 | 节拍 |
```

##### 小结
**（1）CPU周期**
CPU从内存中读取一个指令字的最短时间。
即一条指令的取出阶段被定义为一个CPU周期时间。
也被叫做“机器周期”。
**（2）时钟周期**
CPU处理操作的最基本单位。
一个CPU周期由若干个时钟周期构成
又被叫做 T周期或节拍（脉冲）。
**（3）指令周期**
CPU取出并执行一条指令所需的全部时间。
包括取指令周期和执行指令周期。其中**取指令周期**包括**取指令**和**分析指令**两个阶段

##### 习题
```
【3-3】下面以计算  X + Y 为例来编制控制计算机/处理器工作的程序。

（1）从内存单元X中取数据送入累加器ACC；

（2） ACC加上内存单元Y中的数据，结果存回ACC中；

（3） ACC的值存入内存单元Z中；

（4）停机。
```

## 计算机指令集概述
**含义**：CPU中用来计算和控制计算机系统的一套指令的集合。
每一种CPU在设计时就规定了一系列与其硬件电路相配合的指令系统
指令集的先进与否，关系到CPU的性能发挥，也是CPU性能体现的一个重要标志。


